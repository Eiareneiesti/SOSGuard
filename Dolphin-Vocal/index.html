<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Audio Recording and Raw Feature Extraction</title>
</head>
<body>
    <h1>Audio Recording and Raw Feature Extraction</h1>

    <p>
        <button id="record-button">Start Recording</button>
    </p>

    <div id="results"></div>

    <script>
        let mediaRecorder;
        let audioChunks = [];

        const recordButton = document.getElementById('record-button');
        const resultsDiv = document.getElementById('results');

        recordButton.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                stopRecording();
                recordButton.textContent = 'Start Recording';
            } else {
                startRecording();
                recordButton.textContent = 'Stop Recording';
            }
        });

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.addEventListener('dataavailable', event => {
                    audioChunks.push(event.data);
                });

                mediaRecorder.addEventListener('stop', () => {
                    const audioBlob = new Blob(audioChunks);
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);

                    audio.addEventListener('loadedmetadata', () => {
                        const duration = audio.duration;
                        const audioFeatures = extractAudioFeatures(audio);

                        resultsDiv.textContent = `Duration: ${duration.toFixed(2)} seconds\n`;
                        resultsDiv.textContent += `Max Amplitude: ${audioFeatures.maxAmplitude.toFixed(2)}\n`;
                        resultsDiv.textContent += `Min Amplitude: ${audioFeatures.minAmplitude.toFixed(2)}\n`;
                        resultsDiv.textContent += `Average Amplitude: ${audioFeatures.averageAmplitude.toFixed(2)}\n`;
                    });
                });

                mediaRecorder.start();
            } catch (error) {
                console.error('Error starting recording:', error);
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }

        function extractAudioFeatures(audio) {
            const audioContext = new AudioContext();
            const source = audioContext.createMediaElementSource(audio);
            const analyser = audioContext.createAnalyser();

            source.connect(analyser);
            analyser.connect(audioContext.destination);

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            analyser.getByteTimeDomainData(dataArray);

            let maxAmplitude = -Infinity;
            let minAmplitude = Infinity;
            let sumAmplitude = 0;

            for (let i = 0; i < bufferLength; i++) {
                const amplitude = (dataArray[i] - 128) / 128; // Normalize amplitude to [-1, 1]
                maxAmplitude = Math.max(maxAmplitude, amplitude);
                minAmplitude = Math.min(minAmplitude, amplitude);
                sumAmplitude += amplitude;
            }

            const averageAmplitude = sumAmplitude / bufferLength;

            return {
                maxAmplitude,
                minAmplitude,
                averageAmplitude
            };
        }
    </script>
</body>
</html>

</body>
</html>
