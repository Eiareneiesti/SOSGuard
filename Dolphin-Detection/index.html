<body>
  <div id="main">
    <canvas id="myOutputCanvas" style="position:relative; left:0px; top:0px; width:3000px; height:2000px;"></canvas> <br>    

    <table border=1 style="position:absolute; left:800px; top:0px;">
      <tr><td>
        
        Version 0.9.19 <br>
        
        <div id="description">
          <div id="description-title" style="font-size:30px">Demo Edge Impulse WASM</div>
          Frequency ms <input type="text" id="myText01" value="130" onChange="{
            myFrequencyMs = this.value;
            clearInterval(myTimer01);
            myTimer01 = setInterval(myAudioNow, myFrequencyMs);
          }"><br>
          (square) width/height: <input type="text" value="96" size="5" id="myWidthHeight" READONLY> <br>
          <div id="myDiv01" style="font-size:30px">...</div>
          Stop Data Collection: <input type="checkbox" id="myCheckbox01"><br>
          Stop All Sounds <input type="checkbox" id="myCheckbox02sounds"><br>
          <textarea id="myTextArea01" style="display:none;" rows="10" cols="70">...</textarea> <br> <br> <br>
        </div>
      </td></tr>
    </table>
  </div>
</body>

<audio src="path/to/backgroundNoise.wav"></audio>
<audio src="path/to/Globicephala_macrorhynchus.wav"></audio>
<audio src="path/to/Grampus_griseus.wav"></audio>
<audio src="path/to/Lagenodelphis_hosei.wav"></audio>
<audio src="path/to/Stenella_longirostis.wav"></audio>

<script>
  let myTimer01 = 0;
  let myOutputString = '';
  let myFrequencyMs = document.getElementById('myText01').value;
  let myWidthHeightSquare = document.getElementById('myWidthHeight').value;

  const myAudioNow = async function() {
    const classifier = new EdgeImpulseClassifier();
    await classifier.init();

    let props = classifier.getProperties();

    myWidthHeightSquare = props.input_width;
    document.getElementById('myWidthHeight').value = props.input_width;

    let audioData = /* Capture audio data from microphone */;

    myOutputString = ''; // Process audio data accordingly

    results = await classifier.classify(myOutputString.split(', '));

    let myTemp = '';
    myTemp = '<table border=1 style="font-size:30px">';

    let myBestClassificationNumber = -1;
    let myBestClassificationValue = 0.25; // lowest best allowable value

    for (let j = 0; j < results.results.length; j++) {
      if (results.results[j].value > myBestClassificationValue) {
        myBestClassificationNumber = j; // find the biggest array value
        myBestClassificationValue = results.results[j].value;
      }
    }

    for (let i = 0; i < results.results.length; i++) {
      if (myBestClassificationNumber == i) { // check if this is the best one
        if (!document.getElementById('myCheckbox02sounds').checked) {
          if (i == 0) { document.getElementsByTagName('audio')[0].currentTime = 0; document.getElementsByTagName('audio')[0].play(); }
          if (i == 1) { document.getElementsByTagName('audio')[1].currentTime = 0; document.getElementsByTagName('audio')[1].play(); }
          if (i == 2) { document.getElementsByTagName('audio')[2].currentTime = 0; document.getElementsByTagName('audio')[2].play(); }
          if (i == 3) { document.getElementsByTagName('audio')[3].currentTime = 0; document.getElementsByTagName('audio')[3].play(); }
          if (i == 4) { document.getElementsByTagName('audio')[4].currentTime = 0; document.getElementsByTagName('audio')[4].play(); }
        }

        myTemp += '<tr><td>' + results.results[i].label + '</td><td><font style=\'color:yellow; background-color:blue;\'>' + results.results[i].value.toFixed(3) + '</font></td></tr>';
      } else {
        myTemp += '<tr><td>' + results.results[i].label + '</td><td>' + results.results[i].value.toFixed(3) + '</td></tr>';
      }
    }

    myTemp += '</table>';
    document.getElementById('myDiv01').innerHTML = ' results.anomaly: ' + results.anomaly + '<br>' + myTemp;
  };

  // main program!
  setupPage();
</script>

<script>
  
 // From the old run_impulse.js file 
  
// Classifier module
let classifierInitialized = false;
Module.onRuntimeInitialized = function() {
    classifierInitialized = true;
};

class EdgeImpulseClassifier {
    _initialized = false;
 
  
  // https://forum.edgeimpulse.com/t/wasm-sound-acceleration-camera-demos/1611/7
      getProperties() {
        return Module.get_properties();
    }

    init() {
        if (classifierInitialized === true) return Promise.resolve();

        return new Promise((resolve) => {
            Module.onRuntimeInitialized = () => {
                resolve();
                classifierInitialized = true;
            };
        });
    }

    classify(rawData, debug = false) {
        if (!classifierInitialized) throw new Error('Module is not initialized');

        const obj = this._arrayToHeap(rawData);
        let ret = Module.run_classifier(obj.buffer.byteOffset, rawData.length, debug);
        Module._free(obj.ptr);

        if (ret.result !== 0) {
            throw new Error('Classification failed (err code: ' + ret.result + ')');
        }


        let jsResult = {
            anomaly: ret.anomaly,
            results: []
        };

        // if ret.size is a function, then this is a new module. Use this API call to prevent leaks.
        // the old API (calling via ret.classification) is still there for backwards compatibility, but leaks some memory
        if (typeof ret.size === 'function') {
            for (let cx = 0; cx < ret.size(); cx++) {
                let c = ret.get(cx);
                jsResult.results.push({ label: c.label, value: c.value });
                c.delete();
            }
        }
        else {
            for (let cx = 0; cx < ret.classification.size(); cx++) {
                let c = ret.classification.get(cx);
                jsResult.results.push({ label: c.label, value: c.value });
                c.delete();
            }
        }

        ret.delete();

        return jsResult;
    }

    _arrayToHeap(data) {
        let typedArray = new Float32Array(data);
        let numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT;
        let ptr = Module._malloc(numBytes);
        let heapBytes = new Uint8Array(Module.HEAPU8.buffer, ptr, numBytes);
        heapBytes.set(new Uint8Array(typedArray.buffer));
        return { ptr: ptr, buffer: heapBytes };
    }
}
  
</script>
