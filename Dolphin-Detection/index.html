<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dolphin Vocalization Classification</title>
</head>
<body>
    <div id="main">
        <h1>Dolphin Vocalization Classification</h1>
        <div id="classification-results">
            <h2>Classification Results</h2>
            <table id="results-table" border="1">
                <tr>
                    <th>Label</th>
                    <th>Confidence</th>
                </tr>
            </table>
        </div>
        <div id="controls">
            <button id="start-recording">Start Recording</button>
            <button id="stop-recording" disabled>Stop Recording</button>
        </div>
    </div>

    <script src="edge-impulse-standalone.js"></script>
    <script>
        let audioContext;
        let audioRecorder;
        let audioStream;

        let classifierInitialized = false;

        // Load the Edge Impulse classifier module
        Module.onRuntimeInitialized = function() {
            classifierInitialized = true;
        };

        class EdgeImpulseClassifier {
            // Initialize the classifier
            init() {
                if (classifierInitialized === true) return Promise.resolve();

                return new Promise((resolve) => {
                    Module.onRuntimeInitialized = () => {
                        resolve();
                        classifierInitialized = true;
                    };
                });
            }

            // Classify audio data
            classify(rawData) {
                if (!classifierInitialized) throw new Error('Module is not initialized');

                const obj = this._arrayToHeap(rawData);
                const ret = Module.run_classifier(obj.buffer.byteOffset, rawData.length);
                Module._free(obj.ptr);

                if (ret.result !== 0) {
                    throw new Error('Classification failed (err code: ' + ret.result + ')');
                }

                const results = {
                    anomaly: ret.anomaly,
                    classifications: []
                };

                for (let i = 0; i < ret.size(); i++) {
                    const c = ret.get(i);
                    results.classifications.push({ label: c.label, value: c.value });
                    c.delete();
                }

                ret.delete();

                return results;
            }

            _arrayToHeap(data) {
                const typedArray = new Float32Array(data);
                const numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT;
                const ptr = Module._malloc(numBytes);
                const heapBytes = new Uint8Array(Module.HEAPU8.buffer, ptr, numBytes);
                heapBytes.set(new Uint8Array(typedArray.buffer));
                return { ptr: ptr, buffer: heapBytes };
            }
        }

        // Initialize the classifier
        const classifier = new EdgeImpulseClassifier();
        classifier.init().then(() => {
            console.log('Classifier initialized successfully');
        }).catch(error => {
            console.error('Failed to initialize classifier:', error);
        });

        // Function to start recording audio
        function startRecording() {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    audioStream = stream;
                    audioContext = new AudioContext();
                    audioRecorder = new Recorder(audioContext.createMediaStreamSource(stream));
                    audioRecorder.record();
                    document.getElementById('start-recording').disabled = true;
                    document.getElementById('stop-recording').disabled = false;
                })
                .catch(error => {
                    console.error('Failed to get user media:', error);
                });
        }

        // Function to stop recording audio and classify
        function stopRecording() {
            audioRecorder.stop();
            audioStream.getAudioTracks()[0].stop();
            audioRecorder.exportWAV(blob => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const audioData = new Float32Array(reader.result);
                    classifyAudio(audioData);
                };
                reader.readAsArrayBuffer(blob);
            });
            document.getElementById('start-recording').disabled = false;
            document.getElementById('stop-recording').disabled = true;
        }

        // Function to classify audio data
        function classifyAudio(audioData) {
            try {
                const results = classifier.classify(audioData);
                updateClassificationResults(results);
            } catch (error) {
                console.error('Classification error:', error);
            }
        }

        // Function to update the classification results in the UI
        function updateClassificationResults(results) {
            const table = document.getElementById('results-table');
            table.innerHTML = `
                <tr>
                    <th>Label</th>
                    <th>Confidence</th>
                </tr>
            `;
            results.classifications.forEach(classification => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${classification.label}</td>
                    <td>${classification.value.toFixed(3)}</td>
                `;
                table.appendChild(row);
            });
        }

        // Attach event listeners to recording controls
        document.getElementById('start-recording').addEventListener('click', startRecording);
        document.getElementById('stop-recording').addEventListener('click', stopRecording);
    </script>
</body>
</html>
